UI:

Case 1: checkbox that reveals new UI

	{
		ui::checkbox check_1{panel};	// checkbox appears
		check_1.checked([&](){			// start coroutine when checked
			ui::checkbox check_2{panel};	// new checkbox appears on panel
			await(check_1.unchecked);		// coroutine suspends until check_1 is unchecked, or the observable is killed
			// check_2 disappears
		});

		// check_1 disappears
		// check_2 must be cleaned up: how?
		//  solution #1: macro ui_await() that can return
		//  solution #2: await() returns status
		//	=> signal observers that the observable has been deleted

		// check_1 disappears
		// check_1.checked is deleted
		// check_1.checked sends deletion signal
		// await(check_1) resumes
		// check_2 disappears
	}

Case 2: checkbox that enables/disables UI

	{
		observable<bool> value;
		ui::checkbox check_1{panel, value};
		ui::checkbox check_2{panel, value};
		// check_1 & check_2 are in sync
		// how?
		// value is an observable (type boolean)
		// (less intrusive) store a reference/pointer to value, and poll
		// no need for a notification system (optional)
		check_1.value([&](bool b){check_2.enable(b);});
	}


Case 3: coroutine termination/cancellation
	auto r = await(stuff())
	if (!r) return;
	co_await apply.click | cancel;


Case 4: FSM with coroutines, composition of awaitables
	result = co_await apply.click | mousemove.click | cancel;
	switch (result) 
	{
	case <0>:
	case <1>:
	case <2>:
	}

	show_dialog(cancellation cancel) 
	{
		auto ui_root = ui::root_window();
		ui::input_float inpfloat{ui_root};
		co_await inpfloat.value_changed | cancel;
		return inpfloat.value;
		// OR
		// (can be cancelled by user or by program)
		return co_await inpfloat.value | cancel | inpfloat.cancel;
	}

	main() 
	{
		cancellation close_dialog;
		show_dialog(close_dialog);
		=> cancellation destructor cancels the coroutine
		co_await 20s;	// timeout
		close_dialog.cancel();
	}

ui::Widget {
	ui::Widget {},
	ui::Widget {},
},
// Can't do that: ambiguity between move-constructor and content-constructor

// OK: no ambiguity, but more verbose
ui::Widget {
	ui::Content {
		ui::Widget {},
	}
}

ui::CollapsiblePanel {
	"name",
	ui::Content {
		...
	}
};




Coroutine suspension:
	await
	yield


Asynchronous coroutine resume?
i.e. when an event is signalled, but we do not want to run the coroutine immediately
DONE with schedules


Framebuffer:
-> a collection of draw attachements and optionally one depth attachement
-> groups together a set of render targets
-> an image is implicitly convertible to a framebuffer
-> cache the opengl framebuffer
-> not a value type (only holds references)

State group:
-> a collection of bindings

draw_utils.hpp
- draw_2d_mesh<T>(framebuffer&, vertex_buffer<T>, GLSL, ...)
- draw_2d_quad(framebuffer&, const rect_2d&, texcoords, ...)
- draw_2d_quad(framebuffer&, vec4 p1, vec4 p2, texcoords, ...)
- draw_line(...)
- draw_3d_mesh(framebuffer&, vertex_buffer<T>, mat4 object, mat4 viewproj, ...)


vis_utils.hpp
Debug windows (ui + coroutines)
- vis::show_image(image...)
- image_vis_params:
	clamp, scale, colormap
	show color picker

API proposal:

node:
	node states: 
		instantiated
		bound
		validated
		finalized
	virtual methods:
		+ validate_inputs
		+ finalize
		+ execute

resource_allocator:
	+ request_framebuffer(images)
	+ request_image(desc)
	+ request_buffer(size...)
	+ request_dynamic_buffer(...)

edge != resource

node creation: named constructor
value binding: pass to constructor


Issue: passing on frame-varying uniforms



Dummy nodes VS unbound inputs?

Unbound, but specified inputs 

node.input(0).bind(prev.output(0))
node.input(1).bind(prev.output(0).subimage(0).subregion({0,0},{120,120}))

dummy_node img0 { format...};
dummy_node img1 { format...};
node = new node{img0, img1};
img0.bind(prev.output(0).subimage(0));
img0.bind(prev.output(0).subimage(0).subregion({0,0},{120,120}))


node.input(0).bind(...) => must check that the new binding has the same format 

// can rebind

Alternate UI system:
_____________________________

Needs an entity-component framework

Copy unity:
RectTransform -> rect_transform component
can attach layout controllers (that modifies the rect_transform according to child element)


Programmatically creating UI elements:
create entity, attach rect transform, attach layout controller, attach visual or interaction component

RAII with entities:

{
Entity ent(this->entity());
...
<ent, children and attached components deleted here>
}


Entities:
Owns their components
Storage: either on the heap, or on the stack (unmovable) for temporary entities

Requirements:
adding/removing entities must have close to zero overhead
same for components
enumerating children must be fast

Entities are:
- UI elements
- Scene objects

Ownership and storage decoupled from hierarchy.
Component storage: stack? owned?


Prefabs = functions?
Prefabs = entity hierarchy

Grouping of entities: 
entities can be in an std::vector<> (for owned entities)

Key: DATA-DRIVEN

{
	Entity e;
	e.addComponent<>();
	e.addComponent<>();
	return e;	// issue: if a component has stored a reference to the entity on initialization, this reference is invalidated
	// solution: entity is a value type (reference wrapper) that stores a reference to the real entity, pass by copy
	// issue: when to delete the underlying entity?
	// solution 2: allocate all entities on the heap, use unique_ptr (entity::ptr)

	entity::ptr e = entity::create();
	e->add_component<...>(*e, ...);
	e->add_component<...>(*e, ...);
	return std::move(e);
}

{
	entity::ptr e2 = ...;
	entity::ptr e3 = ...;
	// transferring ownership: e2 is now invalid
	e->add_child(std::move(e2));
	// not transferring ownership: e3 will be deleted when it goes out of scope
	e->add_child(e3);
	// creating children: 
}

// scene->create_entity() -> entity_ptr
// Create an entity in the scene.
// The entity lives until entity->destroy() is called and all components release their references to the entity.
// 
// unique_entity:
// Wraps an entity_ptr. Calls entity_ptr->destroy() when the object goes out of scope.


// all script instances are nonmoveable (but can be copied)
[[meta(script)]]
class blinker : script_component 
{
public:

	[[meta(UISlider(0.0f, 1.0f))]]
	float frequency;

	blinker() {

	}

	std::future<> blink() {
		bool status = false;
		while (true)
		{
			co_await (wait_for_seconds(20s) | terminate);
			entity().get_component<Renderer>().set_visible(false);
		}
	}

private:

};


=======
- animator scripts
	

=======
- make it easy to create new nodes
	* generic code for input validation
	* generic code for handling resource residency

- draw, then compute, then draw
	image img1 { format::rgba32f,  ... };
	image img2 { format::depth32f, ... };
	auto draw = op_draw({img1, img2}, ...);
	auto color_out = draw.output(0);
-> user manipulates resources (buffers & images) vs nodes?
	- resources: need multiple return values & by-ref returns
		- not clear who owns the resource
-> sequencing draws:
	- use draw_nodes and compute_nodes
-> in-place draws:
	- enforced by the resource allocator
	- immediate draws must go through a draw_node or a compute_node
	- cannot draw on an arbitrary image
	- no need to create a framebuffer manually

-> node inputs: need validation
	- verify constraints on creation

-> I/O constraints:
	- residency (host/device/implicit) or don't care
		-> residency constraints always met (handled by the allocator)
	- dimension (1d, 2d, 3d, cubemap) or don't care
	- format 
		-> list of supported formats?
		-> callback to check if the format is correct

	- declaring inputs?
		this->input(0).validate([](auto in) { in.type == ...; }

	- for each input: callback for verification
	- allow_subimages / allow_regions / allow_buffer_slices
		-> always met: if a node cannot operate on subimages/regions, 
			then a new image is created with the region contents 

-> actual resources: not owned by image & buffer nodes
	passed to ops when executing

-> Type safety?

-> node states:
	
	UNBOUND - inputs not bound
	PARTIALLY BOUND - some inputs bound, output partially specified (optional)
	BOUND - node is fully bound
	VALIDATED - node is fully bound and its inputs are validated, outputs are specified
	FINALIZED - resources for input and output are resolved, the node is ready to be executed

-> concrete resources:
	image, CPU/GPU (full)
	subimage, CPU/GPU
	region, CPU/GPU
	buffer

clear_op
region_op 
subimage_op
compute_op
draw_op
msaa_resolve_op
generate_mipmaps_op
ping_pong_op

subimage_op:
	- in: format=any, size=any, residency=any
	- out: format=in.format, size=any, residency=same as in
		storage=in.subresource[index]


First component: 2D shapes
______________________________

Data=NVG draw commands (function)

transform, shape_2d, sprite



Shading nodes: also entities with components
______________________________

Primitives = 
	compute shader
	full-screen raster pass
		- input: textures 
		- output: textures & other stuff
	geometry generator:
		- input: scene
		- output: vertices 
	vertex shader
		- input: vertices
		- output: vertices
	rasterizer:
		- input: vertices
		- output: fragment stream
	fragment shader
		+ predefined fragment nodes
		- input: fragment stream
		- output: fragment stream
	render target
		- input: fragment stream
		- output: texture
	render to screen
		- input: fragment stream

- Prefab nodes = data
- Endpoint = 
	- name
	- type (or unspecified)
		texture, fragment stream, vertex stream, buffer, texels
	- link (entity+endpoint name) (or unspecified)
- EndpointsComponent: stores/manages inputs and outputs
- NodeBehaviorComponent: stores behavior


- Scene renderer node:
	+ camera
	+ subpixelJitter
	+ temporalAAMask
	Properties:
	TAASampleIndex
	TAASampleCount

Shaders = GLSL expressions (GPU)
OR
C++ code (runtime-compiled)
Can register external libraries and #include them in CPU shaders
(cool for geometry generators)



Editor UI? 
______________________________

Different (at first) from game UI.
Something simple. 
No need for animations.
No need for observables. 
Wrap ImGui?

=> Qt: not suitable?
	- issue with opengl contexts
	- cannot use a custom function loader
	- not embeddable in a full-screen game
	+ a lot of stuff is already implemented, can be useful
		(key shortcuts, etc.)

=> ImGui:
	- no support for multiple windows
	- poor support for custom layouts
	- no standard file dialogs, but easily completed by other libraries
	+ extensions for dock windows
	+ with enough determination, can add new features
	+ some experience with it 

Own:
	* shared code between game UI and editor UI
	* support for animations

Idea:
	UI elements are a tree of entities
	box = rect_transform
	layout system = set of layout script components
	rendering = anything (nanovg, for example)
		- hierarchy of clipping masks

UI components:
	- Rect transform
	- visual component
	- layout script
	- behavior script


Tree view?
List view?
Table view?
	=> spawn temporary entities each frame



UI goals:
- can overlay on a 3D scene
- Good OS integration (e.g. Ctrl-C/Ctrl-V support, screen reader compatibility)
- easy custom rendering

UI alternatives:

ImGui:
- good with OpenGL
- poor OS inte

Qt:
- OpenGL support
- cannot overlay?



Entity system:
______________________________





Base editor:
______________________________

- Tabs
- image views
- node editor
- GUI for introspection of components
- Scene browser
- Cameras
- 3D manipulators
- Asset browser
	images, 3D models, animations, curves...

scene_view
scene_browser
component_editor
asset_browser
node_editor

- 'static' resources:
	-> user-editable
	concrete data

- 'live' resources:
	-> read-only data, procedurally generated by nodes from other data
	like G-buffers generated from the scene

-> instantiate prefab node networks
	-> problem: node networks could share resources?



Extensible editor:
______________________________

Scripts can open image views, scene views with camera, and override behaviors.
Can reload editor scripts on-the-fly.




=======
Reflection database:

Queries: like AST matchers

isRecordDecl
isVarDecl
isGlobalScope
hasScope(...)
hasAttr(...)

${#decls}$
${#isRecord}$
std::array<meta::field, ${numFields}$> fields = { 
	${#fields}$ 
	${#isPublic}$
	meta::field { "${qualType}$", "${name}$" } 
	${/isPublic}$
	${/fields}$
};
${/isRecord}$
${/decls}$



${#decls}$
${#isEnum}$
// generated by meta<enum_type>::get_enum_name(enum_type value)
template <> const char* meta<${qualName}$>::get_enum_name(${qualName}$ value) {
	switch (value) {
	${#enumerators}$
	case ${name}$: return "${name}$";
	${/enumerators}$
	default: return "<invalid>";
	}
}

// generated by meta<enum_type>::get_enum_value(const char* name)
template <> ${qualName}$ meta<${qualName}$>::get_enum_value(const char* name) {
	std::string namestr{name};
	${#enumerators}$
	${#isFirst}$
	if (namestr == "${name}$") { return true; }
	${/isFirst}$
	${^isFirst}$
	else if (namestr == "${name}$") { return true; }
	${/isFirst}$
	${/enumerators}$
	return false;
}
${/isEnum}$
${/decls}$


${#decls}$
// attribute instances for ${qualName}$
namespace attr_${declID}$ {
${#attributes}$
${qualType} i_${attrID}$ = ${initializerExpr}$;
${/attributes}$
}

// attribute table for ${qualName}$
// typeinfo hash code -> pointer to attribute instance
std::array<meta::attr_entry, ${numAttr}$> attr_table_${declID}$ = {{
${#attributes}$
	{ std::type_index{typeid(${qualType}$)}, &attr_${declID}$::${attrID}$ },
${/attributes}$
}};
${/decls}$



Choosing a scripting language:
____________________________________

1. Statically typed
	with good generics
	not javascript
2. Compiles or JITs to native code
3. Excellent tooling 
	Autocompletion, go-to definition, type information on variables (at least the features of C# intellisense)
	Also a good debugger
4. Supports coroutines (natively)
5.** Can easily expose native objects/native functions
6. Live code editing
7. Good reflection abilities
8. Ideally: could write shaders in it

Use C++ for the heavy lifting (physics, mesh processing, animation stuff, generation of command buffer, culling)
Use the reflection generator to automatically generate bindings
=> NO C++ for the scripting (live coding) part
	-> memory safety is absolutely mandatory 


=> Ideas:
* Generate ImGui code automatically for component structs.
* Add a 'DisplayName' attribute to components.
* Create and inspect structs while the program is running.



// A.cpp
	import B;
	struct A {
		B b;
	}


// B.cpp
	import A;
	struct B {
		A a;
	};

	void stuff(A a);


A.cpp name pass:
	A: struct;
B.cpp name pass:
	B: struct;

A.cpp main pass:
	needs definition for B
	found in B.cpp
	trigger main pass for B

B.cpp main pass:
	needs definition for A
	found in A.cpp but is incomplete => error
	stuff(A a): needs definition for A



C# replacements:
____________________________________

GLM => GLMSharp or equivalent
glloadgen => OpenTK.Next
cppformat => BCL
experimental/filesystem => BCL
optional/variant/boost::hana => unapplicable
boost::context => built-in coroutines
imgui => ??? (windows forms?)
nanovg => ??? ()
autograph => custom port (has the potential to be cleaner)
json => anything goes
font rendering => ???



Priorities 
____________________________________

1. Quick iteration
   Hot module reload
   live code editing
   REPL with autocomplete

2. Performance
   Predictable and measurable
   Low overhead


3 options
____________________________________

* Full C++, with lightweight scripting (Lua)

* Full C#, with perf-critical parts in C++
	* Scripts in another assembly
	* Can probably embed a REPL
	* HUGE benefits in terms of ease of coding
	* Issue: interop (must load an external DLL and C++ runtime)
	* Issue: portability
	* Issue: interop with the **many** existing C/C++ libraries
	* Issue: no precise memory management
	* At some point, will probably be able to compile to native code
	* Abandon autograph-gl, reflection generator 

* C++ with embedded Mono
	* Issue: exposing types?
	** WINNER **

Things done in C#:
* UI components (ManagedComponent)
	* Garbage collected components
* Entity wrapper: struct type
* RenderGraph generation?


Things done in C++:
* Physics
* Scene rendering 
	* Terrain generation
	* Occlusion culling 
* Render graph compilation
* Render graph evaluation


If using existing C++ libraries is a concern: use C++
else: go with C#



Derive from base entity class
____________________________________

Entity
+ SceneEntity
+ UIWidget


Components:
	- SceneObject
		+parent, children, transform
	- HUDWidget
		+parent, children, recttransform layoutcontroller
	- Physics


MAIN ISSUE:
- it makes no sense for an entity to have an HUDWidget component outside of a HUD entity


SceneEntity:
	* (FIXED) Physics
	* (FIXED) Transform
Scene2DEntity:
	* (FIXED) Physics 2D
	* (FIXED) Transform 2D 
HUDEntity:
	* (FIXED) Ref to parent entity
	* (FIXED) Rect transform
	* (FIXED) (OPTIONAL) Layout script

HUD:
	* vector of HUDEntities


Strong refs VS IDs:

IDs: can invalidate, but needs a fat pointer
=> strong refs


Performance-oriented:
_________________________________

Components stored in contiguous memory
Zero data overhead
Can be reordered: access by ID

=> makes no sense in most of the cases
	Example: transform components are not updated in a straight loop
	they can be updated by the physics system, for entities with physics, or follow scripts, or animators, or whatever
	=> no linear update

Same with HUD: no linear updates?


Flexibility:
_________________________________

Entity -> bag of components
Fast query by type



Rendering system:
_________________________________

Input = scene
=> update transform hierarchy = non-linear traversal


Fat pointer to entity = 
	ID + pointer to scene (used in scripts)
	getComponent/addComponent


3D scene VS HUD
_________________________________

HUD base component?

// Scene = group of entities
class Scene;

Scene world;
Scene HUD;
Scene inventoryScreen;
Scene menuScreen;


// Find HUD roots (entity with HUDRootComponent? Canvas?)
// Create render list
// Sort by depth
// Render
HUD.render(Entity e)
{
	// recursively render 
}

// Find root transforms
// Update world->view matrices
// Create render list(s)
// Do occlusion culling
renderWorld(Scene& world);


Scenes = entity containers
Bikeshedding: layers?



Example: menu screen

A global script listens to the ESC key
ESC key pressed:
	- option 1: a 2D HUD node is revealed in the main scene, signal event HUD.activated
		-> HUD children have scripts that respond to this event and animates the HUD elements
		Q: How should the HUD node know when to render?
			=> Z-order, or draw buckets?
	- option 2: different scenes
		Q: What advantages?


HUD render order:
	- Z-order in root element
	- Only one root, order children



FINAL DESIGN:
- Observation: I don't care about most of the stuff that entity systems can offer
- But I want a few reusable systems, notably:
	- Rendering
	- 2D rendering 
	- UI widget behaviors
	- Default UI visuals
	- Physics, probably

- The only true extensible way is IDs
- Scene: container of IDs
	- can be overriden to add some convenience methods
- Render optimization granularity = scene?
- Individual systems own components, not entities
- Systems can manage components across scenes

Deletion: invalidation of IDs, and manual garbage collection over component pools
Introspection: manual registration of managers

Scene+ID -> entity
Scene+ID+Component index -> component data

scene.createEntity
scene.createHUDWidget(ID, ...)
scene.createRenderable(ID, ...)

Component lookup:
Old: Entity ptr -> Component table -> Component
New: ID -> (Dictionary lookup) Component


1 .. 100

40 41 42 45 70

Query 80:
80 > 42
80 > 45
80 > 70
End: not found

Must decouple scene and component maps
Otherwise: circular dependencies

scene.getComponent<TypeAndSystem>(id)
VS
TypeAndSystem::getComponent(scene, id)
VS
system.getComponent(id)

Should not have to pass around the component manager

ComponentType::get(scene, id)

Trivial components: just use a default manager?

=> scene plugins

ComponentType::get(scene, id)
-> Plugin::getComponent(scene, id) (INLINE)
-> static_cast<Plugin>(scene.getPlugin(Plugin::index))->getComponent(id) (INLINE)


-> One plugin instance per scene?
-> One global plugin instance?
	+ no need to register components when creating a scene
	- global component store: must have scene IDs


// Option #1
RectTransform::get(scene, id)
// Option #2
scene.getComponent<T>(id)
// Option #3


HUDElement:
	+Selectable: next, prev
	+transform
	+


Consider:
- scripts
- fast iteration


Alternative: parallel scenes

Scene: 
	hierarchy of transforms

PhysicsScene
EnemiesScene
RenderableScene



Mono:

1. Load ScriptEngine assembly
2. ScriptEngine assembly scans for updated assemblies in some directory and (re)loads them
	-> use System.IO.FileSystemWatcher
3. The ScriptEngine goes through all classes in the loaded assemblies and call startup methods
Autograph assembly: contains interop structures (generated code?)

In C++: single class ScriptEngine
Just needs to load one assembly

=========================================
Build system:

* CMake-generated global config.hpp
* Reflection generator
	* Only produce a JSON database
	* Use T4 macro processor for generating code

* CMake/C#: 
* Compiling: find correct skia
	* windows: use bundled
	* linux: query from package manager
* CMake reflection generator for C# bindings
* Hook up a debugger
* Use MS runtime on windows

=========================================
Directory structure:

build/				   : Somewhere, contains the executable and the ScriptEngine assembly alongside it
cmake/                 : cmake modules
ext/
include/               : API includes
include/editor 		   : exported types

src/				   : Source code of editor and required assemblies
src/editor/
src/autograph/
src/support/
src/ScriptEngine/	   : ScriptEngine and auto-generated bindings (.sln / .csproj)
		Post-build: copy to data/assemblies
src/AutographBindings/ : Managed bindings
		Post-build: copy to data/assemblies

data/				   : Shared data
data/mono/			   : Mono runtime (optional, but will look here first; otherwise, look in system installation path, probably a bad idea on windows)
data/assemblies/       : required assemblies (ScriptEngine, Autograph bindings)
data/glsl/
data/img/

project/     		   : default project (contains VS/MonoDevelop solution -> references ../data/assemblies/AutographBindings)
project/scripts/
project/scripts/assemblies

<root>
	Managed.sln 	   : VS solution file (refs to src/ScriptEngine/.csproj, src/AutographBindings/.csproj, project/Scripts.csproj) 

=========================================
Build process:

mkdir build
cmake ../
<msbuild>
cd ../src/ScriptEngine
<msbuild C#>

=========================================
Install: 
	gather program and required DLLs from CMake build file
	gather data/ folder




=========================================

TODO:

1. Clean up reflection generator: only generate a JSON database file
	=> OR, ideally: use CppSharp to generate a JSON database?
	=> OR, ideally if this does not pose more problems: remove 
		reflection from the C++ side, move reflection/serialization in
		the C# side
2. Clean up reflection generator: use another method (possibly managed) to create C++ reflection database
	=> JSON with T4 templates?
	=> CppSharp and T4 templates directly?
3. Clean up reflection: rewrite Meta.cpp.in
	=> low priority since it's not really used right now
4. Best short-term solution for C# bindings from C++ is probably CppSharp
	=> can tailor the binding generator
	=> uses clang
	=> DllImport from hosting process
5. Change directory structure
6. Managed subscribers for observables
	Also: efficient native observables?


=========================================

Exported API:
- Vector types
- Matrix types
- Standard components
	- Renderables?
- Input API (ag::*)
- RenderGraph API (ag::rendergraph::*)
- HUD/UI API (ag::ui::*)
- EntityID type
- EntityID managers
- Scene (hierarchy of transforms)
- Mesh type

autograph/Config.hpp
	<config macros>
autograph/Types.hpp
	<vector types>

autograph/editor/RectTransform.hpp
autograph/support/

API rules: 
- no std::experimental 
	=> remove std::experimental::filesystem
	=> replace with std::strings
- use some kind of span type for input arrays
- remove dependency on glm vector types?
	=> typedef them at first
	=> then, replace with lightweight POD types provided with the API
		(binary-compatible with GLM types)
- remove native coroutines (at least until the native coroutine TS is implemented in clang)
	-> replace with async managed scripts
- no vector types in API -> replace with add/remove functions
- use string_views / spans
- Expose some kind of drawing API


Summary of setbacks encountered while trying to bind Skia using Mono

- use __Internal in DllImport attribute (easy)
- for some reason, MSVC decided not to export the skia C API until I used one function (took its address)
	=> probably an optimization; not robust
- Strange error (due to lack of exe configuration) when calling Debug.WriteLineIf
	=> commented out...
- mono_runtime_invoke: pass **pointers** to arguments, even if they are pointers
- mono_method_desc_new: System.IntPtr remaps to intptr in signature? WHERE IS THE DOCUMENTATION ABOUT THAT DAMNIT
- Bindings are ugly (creation of wrapper objects? lookup in dictionary? wtf?)

Actions to take:
- custom bindings to skia
- manually register methods to mono instead of relying on dllexport
- cleanup assembly loading code
- implement hot-reloading (unload and reload the assembly)
- implement a GUI in C# with the skia bindings / move it in the C++ side when done
- Minimal UI drawing code in C++ to C#
	(parse SVG?)

C++ editor UI / C# UI interop:
-> buttons, panels, sliders, edit box, text box, automatic layout
-> automatic layout

C++ editor UI API:

RAII objects with coroutines/lightweight threads:
- ui::Panel { 
	ui::Button { "name" }.onClick(callback);
	ui::Button
 }



Goal: 
1. Editor for rendering pipelines
2. Scene renderer 
	- with animations
3. Scriptable pipeline and UI (C#)
4. Game?

UI goals:
1. data-driven
	-> no need to call setXXX(); variables are read every frame
	-> events for user input
2. Separate visual tree
3. Create UI from C++
4. RAII widgets (visual lifetime = widget lifetime = scope)

	{
		std::string s;

		auto button = c.button("OK");
		auto ui = c.panel( 
			GridLayout{2,2},
			TextEdit{s}, button,
			TextEdit{s2},
			ColorPicker
		);

		co_await button.clicked();
	}

Custom widgets?
Widget = Visual + Behavior
	Visual = element in the visual tree
		   = transform, size, parent, children, layout element
		   sealed
    Behavior = behavior and appearence
    	- preferred size
    	- cached data
    	- onPointerDown, onPointerUp, etc.
    	- render(Visual)


    	{
    		// okButton is orphaned
    		auto okButton = <button>("OK");
	    	auto panel = ui.verticalPanel(
	    		// parent 
	    		okButton,
	    		// parent and take ownership (rvalue refs)
	    		<separator>(),
	    		<ColorPicker>(),
	    		<textEdit>(s)
	    	);

	    	// add and transfer visual lifetime (panel is orphaned when parent is deleted)
	    	parent.add(panel);

	    	// visual lifetime != object lifetime

	    	// panel is destroyed here: should also destroy its children
	    	// Destroying means orphaning here
	    	// button is destroyed, and has no parent: nothing is done
	    	// if button was destroyed with a parent, it would remove itself from the list of child widgets of the parent
	    	// 
	    	// issue: ownership
	    	// okButton is on the stack: lifetime managed by the user; deletion = orphaning
	    	// ui.separator() is a temporary: resource is owned by the panel; deletion = free memory
	    }


    	ui.addChild(panel, ui.create<Button>())
    	ui.create(xxx) => persistent widget
    	ui::button b{xxx} => scope lifetime


    	// 1.
    	// Create object on stack, orphaned, add to panel, object reference goes out of scope, object removed
    	// 2.
    	// Create object, transfer ownership to panel, but retain a reference 


    	// 1.
    	// Create object, pass ref to coroutine or thread:
    	
    	{
    		ui::button b;
    		co_await b->pressed;
    		// observer is removed

    		// observable is destroyed: send cancellation
    		// coroutine ends: control is transferred to the signal() method of the observable that was just destroyed! 
    	}

    	// Issue: named slots
    	// 

    	ui.vertical(
    		ui.horizontal(
    		),
    		ui.button(
    		)
    	);


UI goals:

- #1: support seamless multi-window
- #2: native dialogs
- #3: Copy/paste, etc. => clipboard access
- 
- #4: Integrable with openGL
- #5: has a dock panel
- #6: Stylable
- #7: Dynamic (pass pointer to data, do not copy data)
- #8: Native menus and context menus
- #9: Accessible?

____________________________________________________

Alternatives to render DAGs for pipeline specification:

Goals: interactivity, performance, flexibility
Use cases:

* Forward rendering:
	(GEOM) Opaque pass, different shaders 
	(GEOM) Transparent pass, different shaders

* Deferred rendering:
 	(GEOM) G-buffer pass 
	(SCREEN) Lighting passes
	(GEOM) Transparent pass

* Postproc:
	(SCREEN) Depth of field: (color,depth) -> color

* Shadow mapping:
	(GEOM) Shadow map generation
	(FRAG) Apply shadow map: snippet included in all fragment shaders

* Temporal AA
* Motion blur
* GPU particles
	(COMPUTE) Update position, velocity -> posBuf, velBuf
	(GEOM) Rendering (posBuf, velBuf)

Example use case:
must be able to 
- add a render target (e.g. emissive component) to all materials, 
- specify the corresponding texture to be used as the render target
- add a post-processing pass influencing the final result with this texture
	=> passes are executed automatically
=> Without having to touch the C++ code

Kinds of passes:
GEOM: input=draw calls and uniforms
SCREEN: input=uniforms, renders a screen quad
COMPUTE: input=uniforms, optionally compute size
FRAG: not a pass, but a snippet added to shaders

Resources:
per-scene,
	G-buffers, temporaries for compositing, etc.
per-material,
	Emissive target (== per-scene)
per-object
	Compute buffers for particle rendering => allocated and managed on the C++ side (makes more sense)
per-pass
	Uniforms (== inputs and outputs)
	=> allocated on the C++ side (w/ UpdateBuffers)

global uniforms:
	-> single values or uniform buffers
		-> special syntax?
	-> uniforms affecting only a group of shaders/passes
	-> specify when creating shaders (depends-on light-list)

In lua:

require 'module'
	will create all resources specified in the module (pipeline globals)

class Pipeline
	- context for all resources
	- owns all resources
	- load effects into this pipeline
	- load(effectFile)
	- get(effect-id)
	- global parameters => uniforms

e.g.
	pp.load("scene.fxlua");

Allocate G-buffers and other postproc targets (DOF, etc.)

	pp.load("glassmaterial.fxlua");

Adds a material (translucent pass defined in C++)

	pp.load("emissive.fxlua")

Pass variants:
	-> Dynamically compiled

Adds a material (opaque), allocate a new render texture (emissive), adds postproc passes (bloom)
Passes can have dependencies -> DAG
Some passes are self-contained, other must receive data from the C++ side
-> SCREEN passes are self-contained
-> Some COMPUTE passes are self-contained

for each opaque object:
	pass = pp.getGeometryPass(material.name)	// no dependencies (other than global resources)
	drawPass(vbo, ibo, modelMat, camera, etc...)

for each transparent object:
	pass = pp.getGeometryPass(material.name)
	drawPass(...)

final result:
	pass = pp.getScreenPass('final')
	runPass()	// will render to screen



using a technique:
	tech = pp.createTechniqueInstance('....')
	tech->setXXX(...)
	pass = tech->getPass('name')
	=> pass points back to tech


Technique state
	shared between a set of passes
Pass state
	state for one shader variant
Dynamic state
	state for one invocation of the shader



stateGroups:
- immutable set of bindings (e.g. Textures, UBOs, SSBO, RT, draw states, programs) 
	array of (slot,resource) pairs


Hot-reload:
- pass pointers should still be valid across reloads

- no 'effect files', but hot-reloadable lua scripts that exist in one single Lua VMwwwww<w


____________________________________________________

Scene = hierarchy of transforms

Meshes and models:
Ideally: share vertex buffers, use slices

Models:
Tree of mesh+transform

Mesh:
VBO (ref), IBO (ref)



____________________________________________________

Scene: multiple objects

Object: 
	transform + children
	optional: mesh and 3d canvas

3D canvas: 
	associated to a visual node with a mesh
	contains data for rendering 
	=> texture maps



____________________________________________________

1. Pouvoir facilement utiliser des editeurs externes
	-> ShaderFX, ou n'importe quoi qui produit du GLSL/HLSL
2. Pouvoir facilement lier des variables en tant qu'uniforms
	-> depuis Lua ou C++
3. Pouvoir recharger individuellement des shaders / passes
4. Spécifier les render states dans Lua

Proposition:
- Brique de base = Pass
	-> GLSL program, bindings 
	-> complété par des resources fournies au moment des draw calls
- Shader reload
	-> chaque passe est une ressource
	-> utiliser une référence par nom ou par ID
	-> quand un module lua est rechargé, les passes définies par le fichier sont écrasées, 
		et les entrées correspondantes dans la table des ressources est mise à jour
	-> les modules qui en dépendent sont aussi rechargés

Resource registry = lua table

exemple: sous-dossier resources/img/terrain/grass_0 
	sera accessible dans les scripts avec resources.img.terrain.grass_0
	light userdata: ImageResource
	utilisable en tant que texture: l'objet texture opengl est mis en cache 
		dans ImageResource
	ImageResource:
		- file path

Hot-reloading shaders:
	call 'require' again
	all objects in current namespace are replaced
	C++ references to resources are invalidated?
	-> need 'References by name'

texture dynamique: creation d'une texture dans un script
	tex = Texture2D.new { ... }
	temps de vie: garbage collection
	referencement depuis C++: 
	auto tex = state["tex"]
	OR
	auto tex = getResource<gl::Texture>("resources.tex");

creation d'une texture en C++:
	non-enregistrée: auto tex = gl::Texture (...)
	-> tex est invisible dans les scripts
	-> ownership: C++
	-> temps de vie: scope (short-lived)

	visible dans les scripts (en tant que "name"): state["name"] = std::unique_ptr(...) 
	-> ownership: lua state
	-> temps de vie: garbage-collection (long-lived)

	visible dans les scripts (en tant que "name"): state["name"] = &texture;
	-> ownership: C++
	-> temps de vie: scope
	-> state["name"] devient invalide (dangling pointer) quand la texture est détruite

	(TODO) safe scoped script-visible objects:
	-> ownership: C++
	-> lifetime: scope
	-> state["name"] est mis à nil quand l'objet est détruit
	auto tex = makeScopedObject<gl::Texture>(state, name, args...)

Script variable types:
	ag::vecN types (as userdata)

Proposition: 
typedef pour std::unique_ptr
=> ag::uptr, ag::unique

Next up:
OK Figure out how to control the camera from C++ and Lua
OK Load multiple objects into a scene from an OBJ and FBX; transform hierarchies

Resource management:
- common entry point for resource loading:
	e.g. 
		- rm.getTexture(id)
		- rm.getShader(id)
		- rm.getXXX(id)
		- rm.getBlob(id)
		- rm.getData(id) -> table
- query for modifications:
	- rm.shouldReload(id)
- (TODO) backends:
	- registerDirectory
	- registerArchive
- (TODO) async loading:
	- ???
- raw loading (ignore caches, etc.)
- actual caching is done in Lua
	- cache entry: file name, last load timestamp
- lifetime: unspecified (manual)
	- once loaded, stays in memory until explicitly released
- reloading:
	- 

Meshes -> Mesh cache
Shaders -> ShaderManager
Textures -> TextureManager
Images -> TextureManager
Data tables -> ResourceCache
Binary blobs -> ResourceCache

Role 1:
 - Find/load arbitrary data from an ID
 	ID -> Data
 	ID -> File path
 == ResourceManager

Role 2:
 - Cache already loaded data
 == ResourceManager

Role 3: 
 convert raw data to an optimized in-memory representation
 == TextureManager (TextureLoader), ShaderManager


TODO:
* Move resourceManager role 1 into application (make global)
* Provide global: findResourcePath(id, allowedExts) [Application.h]
* Provide global: addResourcePath(path) [Application.h]
* Provide global: addScriptPath(path) [Application.h]
* Modules:
	Graphics [ImageUtils, RenderUtils, etc.]
	Audio
	Input
	Scene2D
* Avoid free functions like loadTexture(), loadDataTable(), loadShaderPass()
	-> group them?

* Resource Pools:
	pool.getTexture('id')
	pool.getImage('id')
	pool.getShader('id')
	pool.getDataTable('id')
	...
	pool.release()

* Simplification pass:
	merge autograph_support in autograph_engine? (No)
	merge autograph_core in autograph_engine? (No)

	autograph_core => basic types and other stuff that does not require external libs (except glm)
	autograph_support => OS-specific things and useful data structures (no need for window libs)
	autograph_engine => Everything else that should be reusable between applications (windows, meshes, etc.)

* control over the main loop

	{
		Application app;
		app.addResourceDirectory('...');
		app.addLuaPackagePath('...');
	}

* Consistent behavior
	creating a gl::Texture should fail if there is no active context?
	OR => create a context automatically?
	OR => request a context?

* autograph_gl should know if there is an active context

* Simpler, more flexible API
* Goal: minimize boilerplate
	- Application global state is created on first use (singleton)
		- Lua state (private: used by some subsystems)
		- Resource loader
		- Shader cache
	- ag::Window to create a window with an OpenGL context
	- per-window input

	{
		// globals start with an uppercase letter
		ag::AddResourceDirectory(ag::GetActualPath("resources/"));

		// use IDs relative to resource directories instead of full paths 
		// ShaderPasses use a private Lua context
		ag::ShaderPass sp{"shaders/deferredRenderer:main"};
		// Shaders are transparently cached 
		// Alternative:
		// ag::ShaderPass sp = ag::LoadShaderPass{"shaders/wireframe:main"};

		// user scripting context
		// Create a new one, open the default bindings and run the specified script
		ag::ScriptContext script{"scripts/init"};
		// NB: ag::ScriptContext inherits from sol::state

		// window creation
		// Will register an available context to ag::gl
		ag::Window window{640, 480, "Title"};

		// ag::gl is automatically initialized from an available context
		ag::gl::Texture tex = ag::gl::Texture::create2D{640, 480};

		// loading an image from a file to an OpenGL texture:
		auto tex = ag::LoadTexture('img/cavestory/PrtMimi');

		// Resource pool
		ag::ResourcePool pool;
		pool.getTexture('img/splash');

		// Data table (inherits from sol::table, all tables are loaded in a private Lua context, but also isolated)
		ag::DataTable table{'data/level0'};

		// Images
		ag::Image img{''};

		// render loop
		window.onRender([&]() {

		});

		window.onInput([&]() {

		});

	}

	<autograph/engine/ScriptContext.h>
	<autograph/engine/Shader.h> 
	<autograph/engine/Application.h> (global state)


API:

loadTexture(file) -> Texture
loadDataTable()


RenderTargets:
	should support multisampling
	(multisampled image formats?)

Image files:
	{
		ag::Image img {"..."};
		img.getTexture() -> gl::Texture;
	}


FP Camera control:
- WASD
- Mouse move

Terrain rendering:
- base terrain LOD (quadtree?)
- (Very) large view distance
- Procedural generation (vegetation, etc.)
- Object LOD (Trees, rocks)


Suggestion: templated Mesh type
and some standard vertex types

template <typename T, bool indexed>
class Mesh 
{
public:
	// if not indexed
	Mesh(std::vector<T>);
	Mesh(span<T>);
	// if indexed
	Mesh(std::vector<T>, std::vector<unsigned>);

	// getVertexCount()
	// getIndexCount()
	// getVertexBuffer()
	// getIndexBuffer()
};

using Mesh3D = Mesh<Vertex3D>;
using Mesh2D = Mesh<Vertex2D>;

// For generic operations on meshes:
// VertexTraits<T>

*** Suggestion: Drawables
	=> just add an operator()(StateGroup& sg);

	//draw()




IMGUI:
* Imperative
+ handles dynamic content very well
+ Clean, readable code
+ All behavior (rendering, input) in the same procedure: leads to relatively compact code
+ Data only needs to be available when updating the model (no reference is kept to the model between frames)
- All widgets redrawn every frame
- Layout redone every frame
- Input processing tied to frame rate
- Some operations have a frame lag
- Widget must have explicitly assigned IDs
- A component cannot place a widget where it wants:
	i.e. if we are in the onGUI() function, we cannot add an entry to the main menu
		need onMenuBarGUI(), onGUI()

Note: IMGUI is not necessarily fully 'immediate': the visual tree can be cached (and hidden from the programmer)
	can also keep a cached version of the model

In brief: 
	model update fused with declaration of the visual tree 
	No reference is kept to the model
	=> invalidate by default: to avoid recomputation, one could compare the current data with the data at the previous call


RMGUI:
* Declarative, the visual tree is explicit (exists in memory, is controlled by the user)
- A reference to the model is kept by the visual tree
	The model must be available for the lifetime of the widget
- Model updates must be manually pushed to the widgets
	OR polled at regular intervals
- Widgets should hold refs to model data, but this prevents the model data from being moved around in memory

In brief: declaration of visual tree/layout is separated from the model
	=> DO NOT INVALIDATE by default: if the model is not updated, then do not recompute



What we want:
* No need for explicit model updates
	i.e. do not write code twice: once for the layout, once for the model update
	=> model and layout AT THE SAME PLACE
* Having a GUI on a value should not prevent it from moving around in memory. Maybe?

Conclusion:
	IMGUI just has more advantages here => Use it!
		For now?

Use case: 
	big table with many rows and many columns
	each row has an edit box and a button


// IMGUI
for (r in rows) 
{
	ImGui::PushID(i)
	ImGui::Columns()
		...column 1...
	ImGui::NextColumn()
		...column 2...
		if (ImGui::Button()) {
			...
		}
	...
	ImGui::PopID()
	ImGui::NextRow()
}


// Naive RMGUI
// Must listen to changes in the model
onRowAdded() 
{
	grid.addRow(
		ui::Label{...},
		ui::Button { ui::Clicked([] {...} ) },
		ui::EditBox { ui::Changed([] {...})}
	);
}

onRowDeleted() {
	...
}

onRowChanged() {
	grid.removeRow(...)
	grid.addRow(...)
}

// 'Sophisticated' RMGUI
ui::DataGrid {
	ui::Model { 
		[&data](int row) 
		{
			// Issue: internal state is cleared-out when a row is re-created
			return ui::Row{ 
				ui::Label{...}, 
				ui::Button{ ui::Clicked([] { })},
				ui::EditBox{ &data[row].str } 
			}
		}
	}
}

ui::DataGrid {
	ui::View {
		ui::EditBox{},	// View will bind it to the first column of the model
		ui::Text{
			ui::TextStyle{},
		},
	},
	ui::Model {
		[&] (int row) { return make_tuple(...data-from-row...) };
	}
}

Solution:

"state cache"
=> window.table.0.2.scroll = 45	// scroll position of some entry in the table

Models = data only

// On toggle, show UI:
// IMGUI
if (Checkbox(...)) Button();

// RMGUI
ui::Checkbox check{parent};
// called each time the widget 'check' is updated
// will add a new ui::button as a child element
check.contents([] (auto& w) { if (w.checked) return ui::button(); })

// The data grid doesn't know how many rows there are.
// it just remembers the range of rows it has to display.
// If the row doesn't exist, then return empty row.
// The model view is updated every frame (like ImGui)
// Widgets can be static: in that case

// Golden rule: The lifetime of GUI objects must be the same as 

// Node graph model:
// => nodes and connections
//   + models for nodes


Models (data to display) can come from:

- Constants (like text labels)
- Pointer to variables 
	-> they should not move around in memory!
- Closures (read-only)
- Closures with state (read/write)
	[state=0] (auto v) mutable { if (v) { state = *v; } return state; }
	also coroutines
- column reference for grid models
	ui::DataColumn{index}

ListModels are more complicated than just lambdas:
- element count
- 

The model should be available at all times:
-> rendering
-> input processing, for updates
The two may happen at different frequencies



--- Lifetimes ---
	Avoid displaying an interface for an object that is not alive anymore
	IMGUI: Conditional execution; no dangling refs, since the UI is rebuilt from scratch on every frame
		(++) No dangling refs possible
	RMGUI(RAII): Values must outlive the UI element, UI element lifetime controlled by RAII
		(--) Dangling refs possible, but unlikely
	RMGUI(non-owned): UI element owned by the UI visual tree, must manually remove element from visual tree
		(--) Dangling refs possible

--- Layout ---
	Support complex layouts (that depend on the contents of a widget)
	Screen percentage, min value, max value
	IMGUI: Cannot size a widget according to its content 
		OR incurs a one-frame delay for hit-testing
		(--)

	RMGUI: No limitations
		(++)

--- Animation ---
	Can animate properties of individual UI elements
	IMGUI: OK, but code driven (animation mixed with UI definition code)
	 	(--)
	RMGUI: No limitations (attach scripts to UI elements)
		(++) 

--- Optimization ---
	If possible, avoid re-rendering everything each frame
	IMGUI: Difficult, possible through caching (but expensive)
	RMGUI: Possible, but also requires caching
		(--) for both

--- Handling of dynamic data ---
	How the UI handles data that changes every frame
	IMGUI: Perfect
		(++)
	RMGUI: Good if we keep refs to values

--- Dynamic UI ---
	e.g. conditionally reveal an UI element
	IMGUI: easy (conditional structure)
		(++)
	RMGUI: harder; must manually remove/add elements
		(--)

--- Synchronisation with the model ---
	How the UI is bound to the model

--- Drag-and-drop ---


_______________________________________________

Ideas for a gratin-like node editor:

- Interface: ImGui
	- Node graph
	- Image viewer
- Nodes: SceneRenderer, ImagePass, Geometry generators
- Lua scripting (add/remove nodes)
- Parameter linking
- Node groups
- Can control output texture formats
- Can merge GLSL snippets
- Graph structure in C++
- In C++: node evaluation logic / traversal logic
- Links:
	- Images
	- Fragment streams
	- Geometry generators (hot-reloadable Lua code)
	- Generic value nodes (Lua code)
- can add/remove inputs as needed

Internals:
struct Node:
	- input connections
		- type
		- constraints
		- connected resource (Texture, Value, Nothing)
	- output connections
		- connected resource (...)
	- connection update logic
		- when an input has been changed/disconnected/connected
	- rendering logic
	- UI state (screen pos)

struct Connection:
	- constraints (code)

struct ShaderTemplate:
	- Lua shader template code


class SomeNode : public Node 
{
public:
	SomeNode() 
	{
		addInput(...);
		addInput(...);
		addInputConstraint(...);
		addOutput(...);
	}	

	onGui() {
		...
	}

	onInputConnectionUpdate(int i, ...);
	onOutputConnectionUpdate(int i, ...); 
};

_______________________________________________

Scenes:

Scene:
	- Hierarchy of 3D objects with optional meshes
	- ID => SceneObject
Scene2D:
	- Same, with 2D meshes
	- ID => Scene2DObject
RenderableScene:
	- ID => Material and render options
	- ID => RenderObject
PhysicsScene:
	- ID => PhysicsObject (position+velocity)
AI scene:
	- ID (sparse) => AI script

Physics: Scene + PhysicsScene
Rendering: Scene + RenderScene
AI: all scenes

ID maps:
	can be sparse (list of IDs) or dense (array with holes)
	can be direct (contiguous data) or indirect (array of pointers)

ID invalidation:
- remove an ID from the main map
- on next iteration, check if the generation is still OK

Common interface:
- Add an object to a scene with the specified ID:
	add(ID) -> T* (default-initialization)
	add(ID, T) -> T* (initialization)
	if the ID is already present, replace

- Add-if-not-present:
	addIf

- Get an object
	get(ID) -> T*
	if the ID is not there, return nullptr
	if the ID has expired, return nullptr

- Remove an object
	remove(ID)

- Cleanup expired IDs
	cleanup(IDTable)

- Enumerate objects:
	foreach([]())


SceneUtils.cpp: load scene (geometry, materials, textures) from FBX


SceneObject: position + mesh
Renderable: default textures
	albedo
	roughness
	etc.
<Custom components>: custom control maps and textures

VS
Material: how to render stuff (abstract class)


Mental model of a scene:
A scene is composed of entities

SceneObject = transform hierarchy
updates:
	- when an object is deleted (ID invalidated)
		- implicit: remove on next iteration
	- when a sceneObject component is deleted
		- implicit: remove on next iteration

traversal:
	- N ID-queries into the Scene
	- N component query


Optimization:
	ideally, a component query should be as fast as a member access
	same for ID queries

Use case:
	- traversal of the transform hierarchy should be easy
	- obj->findChildByName("...")->getChild(0) ... 
	- VS scene.get(scene.get(obj->findChildByName("whatever"))->getComponent<SceneObject>()->getChild(0))->getComponent<SceneObject>()
	- obj->findChildByName("...")->getComponent<SceneObject>(scene)->

_______________________________________________

ResourceID:
	- isFilesystemResource()	// the path maps to a file on the disk
	- isInternalResource() // has a path or not
	- isFilesystemPath()
	- makeInternalResourceID(name)
	- getResourcePath()	-> resource or filesystem path
	- getFilesystemPath()
	- <comparison operators>
	resourceID: (<resource path> | <filesystem path>):internalID

ResourcePool v2:
get<Type>(resID) -> Type*
- Look for a Loader for Type (ResourceTraits<Type>)

get<Type>(resID, loadFn: resID -> std::unique_ptr<Type>())


what's in an ID?
 models/level1/treasure_chest/treasure_chest:submesh_0
 1. A relative filesystem path:
 	C:/.../resources/models/level1/treasure_chest/treasure_chest.fbx
 2. A relative filesystem directory:
 	C:/.../resources/models/level1/treasure_chest/
 1.1. An absolute filesystem path
 	...
 3. An URL
 4. A path inside an archive
 5. An identifier for an in-memory resource

operations:
 ID -> filesystem path
 ID -> binary stream
 append private identifier
 append path component
 get parent path
 convert to relative path

issue: same ID but different extensions?

Canonical ID:
	- full filesystem path or relative path
		- relative path = path relative to resource roots directories
	- network path / URL
	- path includes extension 
	- internal ID

Canonical ID: 
	- either a filesystem path, an URL or a relative path, with sub-path (optionally)
	- no guarantee of being valid
	- function open() -> ReadStream
	- function resolve() -> 



 
_______________________________________________

Profiler API:

Profiler::beginFrame(): start a new profile
Profiler::endFrame(): end collection, save profile
Profiler::getData(): return profile data saved after calling endFrame()

GPU profiling:
Insert timestamp query in command stream
Next frame: wait for data available


_______________________________________________

API cleanup / simplification

- Lower the number of required headers
	<autograph/Math.h>
		+ Math stuff (AABB, Camera, Types, Math utils, glm)
		+ Independant of any library
		+ Should not be called core (common? shared? math?)
	<autograph/Graphics.h>
		+ Low-level graphics stuff
	<autograph/Engine.h>
		+ Application stuff: 
			+ input
			+ windows
			+ main loop
			+ frames
		+ High-level systems 
			- Scenes
			- GUI utils
			- Debug overlay
			- CVars
			- Lua Shaders
			- Resource management
			- Window management
	<autograph/Support.h>
	<autograph/support/*.h>
		+ On-demand support classes (debug, etc.)

- normalize naming conventions
	+ Math:
		-> namespace ag
	+ Graphics:
		-> namespace ag::graphics? (instead of ag::gl)
		-> no namespace?
	+ Engine:
		-> one namespace per global module
			ag::Profiler
			ag::GuiUtils
			ag::Application
			ag::RenderUtils
		-> rule of thumb: 
			namespace = for global modules
		-> otherwise
			namespace ag
		-> prefer global functions instead of singletons?

- API robustness:
	+ avoid exposing containers (e.g. reference to vector)
		prefer Count/Index function pairs 


_______________________________________________

Long-term low-level rendering API:

Common API for Vulkan/OpenGL

- CommandContext
- ???
- Profit

