UI:

Case 1: checkbox that reveals new UI

	{
		ui::checkbox check_1{panel};	// checkbox appears
		check_1.checked([&](){			// start coroutine when checked
			ui::checkbox check_2{panel};	// new checkbox appears on panel
			await(check_1.unchecked);		// coroutine suspends until check_1 is unchecked, or the observable is killed
			// check_2 disappears
		});

		// check_1 disappears
		// check_2 must be cleaned up: how?
		//  solution #1: macro ui_await() that can return
		//  solution #2: await() returns status
		//	=> signal observers that the observable has been deleted

		// check_1 disappears
		// check_1.checked is deleted
		// check_1.checked sends deletion signal
		// await(check_1) resumes
		// check_2 disappears
	}

Case 2: checkbox that enables/disables UI

	{
		observable<bool> value;
		ui::checkbox check_1{panel, value};
		ui::checkbox check_2{panel, value};
		// check_1 & check_2 are in sync
		// how?
		// value is an observable (type boolean)
		// (less intrusive) store a reference/pointer to value, and poll
		// no need for a notification system (optional)
		check_1.value([&](bool b){check_2.enable(b);});
	}


Case 3: coroutine termination/cancellation
	auto r = await(stuff())
	if (!r) return;
	co_await apply.click | cancel;


Case 4: FSM with coroutines, composition of awaitables
	result = co_await apply.click | mousemove.click | cancel;
	switch (result) 
	{
	case <0>:
	case <1>:
	case <2>:
	}

	show_dialog(cancellation cancel) 
	{
		auto ui_root = ui::root_window();
		ui::input_float inpfloat{ui_root};
		co_await inpfloat.value_changed | cancel;
		return inpfloat.value;
		// OR
		// (can be cancelled by user or by program)
		return co_await inpfloat.value | cancel | inpfloat.cancel;
	}

	main() 
	{
		cancellation close_dialog;
		show_dialog(close_dialog);
		=> cancellation destructor cancels the coroutine
		co_await 20s;	// timeout
		close_dialog.cancel();
	}

Coroutine suspension:
	await
	yield


Asynchronous coroutine resume?
i.e. when an event is signalled, but we do not want to run the coroutine immediately
DONE with schedules


Animation system:
schedule animations


Image pipelines:

-> finish immediate draw/compute
-> GLSL 'library' for common patterns (fullscreen FS, default vertex shader, default 2D VS, etc.)
-> common patterns for compute (filter image, etc.)
-> automatic mip-maps? image pyramids?

Framebuffer:
-> a collection of draw attachements and optionally one depth attachement
-> groups together a set of render targets
-> an image is implicitly convertible to a framebuffer
-> cache the opengl framebuffer
-> not a value type (only holds references)

State group:
-> a collection of bindings

draw_utils.hpp
- draw_2d_mesh<T>(framebuffer&, vertex_buffer<T>, GLSL, ...)
- draw_2d_quad(framebuffer&, const rect_2d&, texcoords, ...)
- draw_2d_quad(framebuffer&, vec4 p1, vec4 p2, texcoords, ...)
- draw_line(...)
- draw_3d_mesh(framebuffer&, vertex_buffer<T>, mat4 object, mat4 viewproj, ...)




vis_utils.hpp
Debug windows (ui + coroutines)
- vis::show_image(image...)
- image_vis_params:
	clamp, scale, colormap
	show color picker

API proposal:

node:
	node states: 
		instantiated
		bound
		validated
		finalized
	virtual methods:
		+ validate_inputs
		+ finalize
		+ execute

resource_allocator:
	+ request_framebuffer(images)
	+ request_image(desc)
	+ request_buffer(size...)
	+ request_dynamic_buffer(...)

edge != resource

node creation: named constructor
value binding: pass to constructor


Issue: passing on frame-varying uniforms



Dummy nodes VS unbound inputs?

Unbound, but specified inputs 

node.input(0).bind(prev.output(0))
node.input(1).bind(prev.output(0).subimage(0).subregion({0,0},{120,120}))

dummy_node img0 { format...};
dummy_node img1 { format...};
node = new node{img0, img1};
img0.bind(prev.output(0).subimage(0));
img0.bind(prev.output(0).subimage(0).subregion({0,0},{120,120}))


node.input(0).bind(...) => must check that the new binding has the same format 

// can rebind

Alternate UI system:
_____________________________

Needs an entity-component framework

Copy unity:
RectTransform -> rect_transform component
can attach layout controllers (that modifies the rect_transform according to child element)


Programmatically creating UI elements:
create entity, attach rect transform, attach layout controller, attach visual or interaction component

RAII with entities:

{
Entity ent(this->entity());
...
<ent, children and attached components deleted here>
}


Entities:
Owns their components
Storage: either on the heap, or on the stack (unmovable) for temporary entities

Requirements:
adding/removing entities must have close to zero overhead
same for components
enumerating children must be fast

Entities are:
- UI elements
- Scene objects

Ownership and storage decoupled from hierarchy.
Component storage: stack? owned?


Prefabs = functions?
Prefabs = entity hierarchy

Grouping of entities: 
entities can be in an std::vector<> (for owned entities)

Key: DATA-DRIVEN

{
	Entity e;
	e.addComponent<>();
	e.addComponent<>();
	return e;	// issue: if a component has stored a reference to the entity on initialization, this reference is invalidated
	// solution: entity is a value type (reference wrapper) that stores a reference to the real entity, pass by copy
	// issue: when to delete the underlying entity?
	// solution 2: allocate all entities on the heap, use unique_ptr (entity::ptr)

	entity::ptr e = entity::create();
	e->add_component<...>(*e, ...);
	e->add_component<...>(*e, ...);
	return std::move(e);
}

{
	entity::ptr e2 = ...;
	entity::ptr e3 = ...;
	// transferring ownership: e2 is now invalid
	e->add_child(std::move(e2));
	// not transferring ownership: e3 will be deleted when it goes out of scope
	e->add_child(e3);
	// creating children: 
}

class blinker : script_component 
{
public:
	blinker() {

	}

	std::future<> blink() {
		bool status = false;
		while (true)
		{
			co_await (wait_for_seconds(20s) | terminate);
			entity().get_component<Renderer>().set_visible(false);
		}
	}

private:

};

