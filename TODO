UI:

Case 1: checkbox that reveals new UI

	{
		ui::checkbox check_1{panel};	// checkbox appears
		check_1.checked([&](){			// start coroutine when checked
			ui::checkbox check_2{panel};	// new checkbox appears on panel
			await(check_1.unchecked);		// coroutine suspends until check_1 is unchecked, or the observable is killed
			// check_2 disappears
		});

		// check_1 disappears
		// check_2 must be cleaned up: how?
		//  solution #1: macro ui_await() that can return
		//  solution #2: await() returns status
		//	=> signal observers that the observable has been deleted

		// check_1 disappears
		// check_1.checked is deleted
		// check_1.checked sends deletion signal
		// await(check_1) resumes
		// check_2 disappears
	}

Case 2: checkbox that enables/disables UI

	{
		observable<bool> value;
		ui::checkbox check_1{panel, value};
		ui::checkbox check_2{panel, value};
		// check_1 & check_2 are in sync
		// how?
		// value is an observable (type boolean)
		// (less intrusive) store a reference/pointer to value, and poll
		// no need for a notification system (optional)
		check_1.value([&](bool b){check_2.enable(b);});
	}


Case 3: coroutine termination/cancellation
	auto r = await(stuff())
	if (!r) return;
	co_await apply.click | cancel;


Case 4: FSM with coroutines, composition of awaitables
	result = co_await apply.click | mousemove.click | cancel;
	switch (result) 
	{
	case <0>:
	case <1>:
	case <2>:
	}

	show_dialog(cancellation cancel) 
	{
		auto ui_root = ui::root_window();
		ui::input_float inpfloat{ui_root};
		co_await inpfloat.value_changed | cancel;
		return inpfloat.value;
		// OR
		// (can be cancelled by user or by program)
		return co_await inpfloat.value | cancel | inpfloat.cancel;
	}

	main() 
	{
		cancellation close_dialog;
		show_dialog(close_dialog);
		=> cancellation destructor cancels the coroutine
		co_await 20s;	// timeout
		close_dialog.cancel();
	}

Coroutine suspension:
	await
	yield


Asynchronous coroutine resume?
i.e. when an event is signalled, but we do not want to run the coroutine immediately
DONE with schedules


Animation system:
schedule animations


Image pipelines:

-> finish immediate draw/compute
-> GLSL 'library' for common patterns (fullscreen FS, default vertex shader, default 2D VS, etc.)
-> common patterns for compute (filter image, etc.)
-> automatic mip-maps? image pyramids?

Framebuffer:
-> a collection of draw attachements and optionally one depth attachement
-> groups together a set of render targets
-> an image is implicitly convertible to a framebuffer
-> cache the opengl framebuffer
-> not a value type (only holds references)

State group:
-> a collection of bindings

draw_utils.hpp
- draw_2d_mesh<T>(framebuffer&, vertex_buffer<T>, GLSL, ...)
- draw_2d_quad(framebuffer&, const rect_2d&, texcoords, ...)
- draw_2d_quad(framebuffer&, vec4 p1, vec4 p2, texcoords, ...)
- draw_line(...)
- draw_3d_mesh(framebuffer&, vertex_buffer<T>, mat4 object, mat4 viewproj, ...)




vis_utils.hpp
Debug windows (ui + coroutines)
- vis::show_image(image...)
- image_vis_params:
	clamp, scale, colormap
	show color picker

API proposal:

node:
	node states: 
		instantiated
		bound
		validated
		finalized
	virtual methods:
		+ validate_inputs
		+ finalize
		+ execute

resource_allocator:
	+ request_framebuffer(images)
	+ request_image(desc)
	+ request_buffer(size...)
	+ request_dynamic_buffer(...)

edge != resource

node creation: named constructor
value binding: pass to constructor


Issue: passing on frame-varying uniforms



Dummy nodes VS unbound inputs?

Unbound, but specified inputs 

node.input(0).bind(prev.output(0))
node.input(1).bind(prev.output(0).subimage(0).subregion({0,0},{120,120}))

dummy_node img0 { format...};
dummy_node img1 { format...};
node = new node{img0, img1};
img0.bind(prev.output(0).subimage(0));
img0.bind(prev.output(0).subimage(0).subregion({0,0},{120,120}))


node.input(0).bind(...) => must check that the new binding has the same format 

- make it easy to create new nodes
	* generic code for input validation
	* generic code for handling resource residency

- draw, then compute, then draw
	image img1 { format::rgba32f,  ... };
	image img2 { format::depth32f, ... };
	auto draw = op_draw({img1, img2}, ...);
	auto color_out = draw.output(0);
-> user manipulates resources (buffers & images) vs nodes?
	- resources: need multiple return values & by-ref returns
		- not clear who owns the resource
-> sequencing draws:
	- use draw_nodes and compute_nodes
-> in-place draws:
	- enforced by the resource allocator
	- immediate draws must go through a draw_node or a compute_node
	- cannot draw on an arbitrary image
	- no need to create a framebuffer manually

-> node inputs: need validation
	- verify constraints on creation

-> I/O constraints:
	- residency (host/device/implicit) or don't care
		-> residency constraints always met (handled by the allocator)
	- dimension (1d, 2d, 3d, cubemap) or don't care
	- format 
		-> list of supported formats?
		-> callback to check if the format is correct

	- declaring inputs?
		this->input(0).validate([](auto in) { in.type == ...; }

	- for each input: callback for verification
	- allow_subimages / allow_regions / allow_buffer_slices
		-> always met: if a node cannot operate on subimages/regions, 
			then a new image is created with the region contents 

-> actual resources: not owned by image & buffer nodes
	passed to ops when executing

-> Type safety?

-> node states:
	
	UNBOUND - inputs not bound
	PARTIALLY BOUND - some inputs bound, output partially specified (optional)
	BOUND - node is fully bound
	VALIDATED - node is fully bound and its inputs are validated, outputs are specified
	FINALIZED - resources for input and output are resolved, the node is ready to be executed

-> concrete resources:
	image, CPU/GPU (full)
	subimage, CPU/GPU
	region, CPU/GPU
	buffer

clear_op
region_op 
subimage_op
compute_op
draw_op
msaa_resolve_op
generate_mipmaps_op
ping_pong_op

subimage_op:
	- in: format=any, size=any, residency=any
	- out: format=in.format, size=any, residency=same as in
		storage=in.subresource[index]

