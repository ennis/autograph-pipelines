UI:

Case 1: checkbox that reveals new UI

	{
		ui::checkbox check_1{panel};	// checkbox appears
		check_1.checked([&](){			// start coroutine when checked
			ui::checkbox check_2{panel};	// new checkbox appears on panel
			await(check_1.unchecked);		// coroutine suspends until check_1 is unchecked, or the observable is killed
			// check_2 disappears
		});

		// check_1 disappears
		// check_2 must be cleaned up: how?
		//  solution #1: macro ui_await() that can return
		//  solution #2: await() returns status
		//	=> signal observers that the observable has been deleted

		// check_1 disappears
		// check_1.checked is deleted
		// check_1.checked sends deletion signal
		// await(check_1) resumes
		// check_2 disappears
	}

Case 2: checkbox that enables/disables UI

	{
		observable<bool> value;
		ui::checkbox check_1{panel, value};
		ui::checkbox check_2{panel, value};
		// check_1 & check_2 are in sync
		// how?
		// value is an observable (type boolean)
		// (less intrusive) store a reference/pointer to value, and poll
		// no need for a notification system (optional)
		check_1.value([&](bool b){check_2.enable(b);});
	}


Case 3: coroutine termination/cancellation
	auto r = await(stuff())
	if (!r) return;
	co_await apply.click | cancel;


Case 4: FSM with coroutines, composition of awaitables
	result = co_await apply.click | mousemove.click | cancel;
	switch (result) 
	{
	case <0>:
	case <1>:
	case <2>:
	}

	show_dialog(cancellation cancel) 
	{
		auto ui_root = ui::root_window();
		ui::input_float inpfloat{ui_root};
		co_await inpfloat.value_changed | cancel;
		return inpfloat.value;
		// OR
		// (can be cancelled by user or by program)
		return co_await inpfloat.value | cancel | inpfloat.cancel;
	}

	main() 
	{
		cancellation close_dialog;
		show_dialog(close_dialog);
		=> cancellation destructor cancels the coroutine
		co_await 20s;	// timeout
		close_dialog.cancel();
	}

Coroutine suspension:
	await
	yield


Asynchronous coroutine resume?
i.e. when an event is signalled, but we do not want to run the coroutine immediately
DONE with schedules


Animation system:
schedule animations


Image pipelines:

-> finish immediate draw/compute
-> GLSL 'library' for common patterns (fullscreen FS, default vertex shader, default 2D VS, etc.)
-> common patterns for compute (filter image, etc.)
-> automatic mip-maps? image pyramids?

Framebuffer:
-> a collection of draw attachements and optionally one depth attachement
-> groups together a set of render targets
-> an image is implicitly convertible to a framebuffer
-> cache the opengl framebuffer
-> not a value type (only holds references)

State group:
-> a collection of bindings

draw_utils.hpp
- draw_2d_mesh<T>(framebuffer&, vertex_buffer<T>, GLSL, ...)
- draw_2d_quad(framebuffer&, const rect_2d&, texcoords, ...)
- draw_2d_quad(framebuffer&, vec4 p1, vec4 p2, texcoords, ...)
- draw_line(...)
- draw_3d_mesh(framebuffer&, vertex_buffer<T>, mat4 object, mat4 viewproj, ...)




vis_utils.hpp
Debug windows (ui + coroutines)
- vis::show_image(image...)
- image_vis_params:
	clamp, scale, colormap
	show color picker

API proposal:

node:
	node states: 
		instantiated
		bound
		validated
		finalized
	virtual methods:
		+ validate_inputs
		+ finalize
		+ execute

resource_allocator:
	+ request_framebuffer(images)
	+ request_image(desc)
	+ request_buffer(size...)
	+ request_dynamic_buffer(...)

edge != resource

node creation: named constructor
value binding: pass to constructor


Issue: passing on frame-varying uniforms



Dummy nodes VS unbound inputs?

Unbound, but specified inputs 

node.input(0).bind(prev.output(0))
node.input(1).bind(prev.output(0).subimage(0).subregion({0,0},{120,120}))

dummy_node img0 { format...};
dummy_node img1 { format...};
node = new node{img0, img1};
img0.bind(prev.output(0).subimage(0));
img0.bind(prev.output(0).subimage(0).subregion({0,0},{120,120}))


node.input(0).bind(...) => must check that the new binding has the same format 

// can rebind

Alternate UI system:
_____________________________

Needs an entity-component framework

Copy unity:
RectTransform -> rect_transform component
can attach layout controllers (that modifies the rect_transform according to child element)


Programmatically creating UI elements:
create entity, attach rect transform, attach layout controller, attach visual or interaction component

RAII with entities:

{
Entity ent(this->entity());
...
<ent, children and attached components deleted here>
}


Entities:
Owns their components
Storage: either on the heap, or on the stack (unmovable) for temporary entities

Requirements:
adding/removing entities must have close to zero overhead
same for components
enumerating children must be fast

Entities are:
- UI elements
- Scene objects

Ownership and storage decoupled from hierarchy.
Component storage: stack? owned?


Prefabs = functions?
Prefabs = entity hierarchy

Grouping of entities: 
entities can be in an std::vector<> (for owned entities)

Key: DATA-DRIVEN

{
	Entity e;
	e.addComponent<>();
	e.addComponent<>();
	return e;	// issue: if a component has stored a reference to the entity on initialization, this reference is invalidated
	// solution: entity is a value type (reference wrapper) that stores a reference to the real entity, pass by copy
	// issue: when to delete the underlying entity?
	// solution 2: allocate all entities on the heap, use unique_ptr (entity::ptr)

	entity::ptr e = entity::create();
	e->add_component<...>(*e, ...);
	e->add_component<...>(*e, ...);
	return std::move(e);
}

{
	entity::ptr e2 = ...;
	entity::ptr e3 = ...;
	// transferring ownership: e2 is now invalid
	e->add_child(std::move(e2));
	// not transferring ownership: e3 will be deleted when it goes out of scope
	e->add_child(e3);
	// creating children: 
}

// all script instances are nonmoveable (but can be copied)
[[meta(script)]]
class blinker : script_component 
{
public:

	[[meta(UISlider(0.0f, 1.0f))]]
	float frequency;

	blinker() {

	}

	std::future<> blink() {
		bool status = false;
		while (true)
		{
			co_await (wait_for_seconds(20s) | terminate);
			entity().get_component<Renderer>().set_visible(false);
		}
	}

private:

};


=======
- animator scripts
	

=======
- make it easy to create new nodes
	* generic code for input validation
	* generic code for handling resource residency

- draw, then compute, then draw
	image img1 { format::rgba32f,  ... };
	image img2 { format::depth32f, ... };
	auto draw = op_draw({img1, img2}, ...);
	auto color_out = draw.output(0);
-> user manipulates resources (buffers & images) vs nodes?
	- resources: need multiple return values & by-ref returns
		- not clear who owns the resource
-> sequencing draws:
	- use draw_nodes and compute_nodes
-> in-place draws:
	- enforced by the resource allocator
	- immediate draws must go through a draw_node or a compute_node
	- cannot draw on an arbitrary image
	- no need to create a framebuffer manually

-> node inputs: need validation
	- verify constraints on creation

-> I/O constraints:
	- residency (host/device/implicit) or don't care
		-> residency constraints always met (handled by the allocator)
	- dimension (1d, 2d, 3d, cubemap) or don't care
	- format 
		-> list of supported formats?
		-> callback to check if the format is correct

	- declaring inputs?
		this->input(0).validate([](auto in) { in.type == ...; }

	- for each input: callback for verification
	- allow_subimages / allow_regions / allow_buffer_slices
		-> always met: if a node cannot operate on subimages/regions, 
			then a new image is created with the region contents 

-> actual resources: not owned by image & buffer nodes
	passed to ops when executing

-> Type safety?

-> node states:
	
	UNBOUND - inputs not bound
	PARTIALLY BOUND - some inputs bound, output partially specified (optional)
	BOUND - node is fully bound
	VALIDATED - node is fully bound and its inputs are validated, outputs are specified
	FINALIZED - resources for input and output are resolved, the node is ready to be executed

-> concrete resources:
	image, CPU/GPU (full)
	subimage, CPU/GPU
	region, CPU/GPU
	buffer

clear_op
region_op 
subimage_op
compute_op
draw_op
msaa_resolve_op
generate_mipmaps_op
ping_pong_op

subimage_op:
	- in: format=any, size=any, residency=any
	- out: format=in.format, size=any, residency=same as in
		storage=in.subresource[index]


First component: 2D shapes
______________________________

Data=NVG draw commands (function)

transform, shape_2d, sprite



Shading nodes: also entities with components
______________________________

Primitives = 
	compute shader
	full-screen raster pass
		- input: textures 
		- output: textures & other stuff
	geometry generator:
		- input: scene
		- output: vertices 
	vertex shader
		- input: vertices
		- output: vertices
	rasterizer:
		- input: vertices
		- output: fragment stream
	fragment shader
		+ predefined fragment nodes
		- input: fragment stream
		- output: fragment stream
	render target
		- input: fragment stream
		- output: texture
	render to screen
		- input: fragment stream

- Prefab nodes = data
- Endpoint = 
	- name
	- type (or unspecified)
		texture, fragment stream, vertex stream, buffer, texels
	- link (entity+endpoint name) (or unspecified)
- EndpointsComponent: stores/manages inputs and outputs
- NodeBehaviorComponent: stores behavior

Shaders = GLSL expressions (GPU)
OR
C++ code (runtime-compiled)
Can register external libraries and #include them in CPU shaders
(cool for geometry generators)


Editor UI? 
______________________________

Different (at first) from game UI.
Something simple. 
No need for animations.
No need for observables. 
Wrap ImGui?


Base editor:
______________________________

- Tabs
- image views
- node editor
- GUI for introspection of components
- Scene browser
- Cameras
- 3D manipulators
- Asset browser
	images, 3D models, animations, curves...

scene_view
scene_browser
component_editor
asset_browser
node_editor

- 'static' resources:
	-> user-editable
	concrete data

- 'live' resources:
	-> read-only data, procedurally generated by nodes from other data
	like G-buffers generated from the scene

-> instantiate prefab node networks
	-> problem: node networks could share resources?

Extensible editor:
______________________________

Scripts can open image views, scene views with camera, and override behaviors.
Can reload editor scripts on-the-fly.




=======
Reflection database:

Queries: like AST matchers

isRecordDecl
isVarDecl
isGlobalScope
hasScope(...)
hasAttr(...)

${#decls}$
${#isRecord}$
std::array<meta::field, ${numFields}$> fields = { 
	${#fields}$ 
	${#isPublic}$
	meta::field { "${qualType}$", "${name}$" } 
	${/isPublic}$
	${/fields}$
};
${/isRecord}$
${/decls}$



${#decls}$
${#isEnum}$
// generated by meta<enum_type>::get_enum_name(enum_type value)
template <> const char* meta<${qualName}$>::get_enum_name(${qualName}$ value) {
	switch (value) {
	${#enumerators}$
	case ${name}$: return "${name}$";
	${/enumerators}$
	default: return "<invalid>";
	}
}

// generated by meta<enum_type>::get_enum_value(const char* name)
template <> ${qualName}$ meta<${qualName}$>::get_enum_value(const char* name) {
	std::string namestr{name};
	${#enumerators}$
	${#isFirst}$
	if (namestr == "${name}$") { return true; }
	${/isFirst}$
	${^isFirst}$
	else if (namestr == "${name}$") { return true; }
	${/isFirst}$
	${/enumerators}$
	return false;
}
${/isEnum}$
${/decls}$


${#decls}$
// attribute instances for ${qualName}$
namespace attr_${declID}$ {
${#attributes}$
${qualType} i_${attrID}$ = ${initializerExpr}$;
${/attributes}$
}

// attribute table for ${qualName}$
// typeinfo hash code -> pointer to attribute instance
std::array<meta::attr_entry, ${numAttr}$> attr_table_${declID}$ = {{
${#attributes}$
	{ std::type_index{typeid(${qualType}$)}, &attr_${declID}$::${attrID}$ },
${/attributes}$
}};
${/decls}$


=> Ideas:
* Generate ImGui code automatically for component structs.
* Add a 'DisplayName' attribute to components.
* Create and inspect structs while the program is running.



// A.cpp
	import B;
	struct A {
		B b;
	}


// B.cpp
	import A;
	struct B {
		A a;
	};

	void stuff(A a);


A.cpp name pass:
	A: struct;
B.cpp name pass:
	B: struct;

A.cpp main pass:
	needs definition for B
	found in B.cpp
	trigger main pass for B

B.cpp main pass:
	needs definition for A
	found in A.cpp but is incomplete => error
	stuff(A a): needs definition for A


