{{=${ }$=}}

${#metaHeaders}$
#include "${.}$"
${/metaHeaders}$
#include <exception>
#include <typeindex>
#include <cstdint>
#include <cstddef>

struct meta_field 
{
const char* qualType;
const char* name;
intptr_t offset;
};

${#decls}$
${#isStruct}$
constexpr std::array<meta_field, ${numPublicFields}$> fields = { {
	${#fields}$ 
	${#isPublic}$
	meta_field { "${qualType}$", "${name}$", offsetof(${classQualName}$, ${name}$) } ,
	${/isPublic}$
	${/fields}$
}};
${/isStruct}$
${/decls}$

template <typename T> const char* get_enum_name(T value);
template <typename T> T get_enum_value(const char* name);

${#decls}$
${#isEnum}$
// generated by meta<enum_type>::get_enum_name(enum_type value)
template <> const char* get_enum_name<${qualName}$>(${qualName}$ value) {
	switch (value) {
	${#enumerators}$
	case ${qualName}$: return "${name}$";
	${/enumerators}$
	default: return "<invalid>";
	}
}

// generated by meta<enum_type>::get_enum_value(const char* name)
template <> ${qualName}$ get_enum_value<${qualName}$>(const char* name) {
	std::string namestr{name};
	${#enumerators}$
	${#isFirst}$
	if (namestr == "${name}$") { return ${qualName}$; }
	${/isFirst}$
	${^isFirst}$
	else if (namestr == "${name}$") { return ${qualName}$; }
	${/isFirst}$
	${/enumerators}$
	std::terminate();
}
${/isEnum}$
${/decls}$

template <typename T> struct meta_attr {};

struct meta_attr_entry {
	std::type_index attr_type;
	const void* data;
};

${#decls}$
${#isType}$
template <> struct meta_attr<${qualName}$> {
	// attribute instances for ${qualName}$
	${#attrs}$
	static constexpr ${qualType}$ A_${attrID}$ = ${initializer}$;
	${/attrs}$
	// attribute table
	const std::array<meta_attr_entry, ${numAttrs}$>& table() {
		static std::array<meta_attr_entry, ${numAttrs}$> data_ = { {
		${#attrs}$
			{ std::type_index{typeid(${qualType}$)}, &meta_attr<${qualName}$>::A_${attrID}$ },
			${/attrs}$
		} };
		return data_;
	}
};
${/isType}$
${/decls}$

