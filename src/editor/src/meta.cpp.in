{{=${ }$=}}
/////////////////////////////////////////////////////////////////////
// Automatically generated file: DO NOT EDIT

${#metaHeaders}$
#include "${.}$"
${/metaHeaders}$
#include <exception>
#include <typeindex>
#include <cstdint>
#include <cstddef>
#include <string>

namespace meta 
{
// base templates
template <typename T> struct record_reflect;

template <typename T> struct enum_reflect;

// https://rmf.io/cxx11/overload-ranking/
struct overload_otherwise {
  overload_otherwise(...) {}
};

template <unsigned I> struct overload_choice : overload_choice<I + 1> {};
// terminate recursive inheritence at a convenient point,
// large enough to cover all cases
template <> struct overload_choice<10> {};

// "for clarity"
struct select_overload : overload_choice<0> {};

// candidates for serialization

template <typename T>
constexpr bool is_msgpack_packable_v =
    std::is_fundamental<T>::value || std::is_same<T, std::string>::value || 
    (std::is_array<T>::value && std::is_fundamental<std::remove_all_extents_t<T>>::value);

//============================================
// #1: msgpack primitive type
//		=> overload selected by Expression SFINAE (p.pack)
template <typename T, typename = std::enable_if_t<is_msgpack_packable_v<T>>>
auto serialize_impl0(overload_choice<0>, packer &p, const T &v)
    -> void {
  p.pack(v);
}

//============================================
// #2: static member serialize
//		=> overload selected by Expression SFINAE (T::serialize)
template <typename T>
auto serialize_impl0(overload_choice<1>, packer &p, const T &v)
    -> decltype(v.serialize(p), void()) {
  T::serialize(p);
}

//============================================
// #3: automatic serialization (structs)
//		=> overload selected by Expression SFINAE
//(record_reflect<T>::serialize_impl)
template <typename T>
auto serialize_impl0(overload_choice<2>, packer &p, const T &v)
    -> decltype(record_reflect<T>::serialize(p, &v), void()) {
  record_reflect<T>::serialize(p, &v);
}

//============================================
// #3: automatic serialization (enums)
//		=> overload selected by Expression SFINAE
//(enum_reflect<T>::serialize_impl)
template <typename T>
auto serialize_impl0(overload_choice<3>, packer &p, const T &v)
    -> decltype(enum_reflect<T>::serialize(p, &v), void()) {
  enum_reflect<T>::serialize(p, &v);
}

//============================================
// #4: default
//		=> output binary data?
template <typename T>
auto serialize_impl0(overload_otherwise, packer &p, const T &v) -> void {}

// dispatcher
template <typename T>
void serialize_impl(packer& p, const T& v)
{
	serialize_impl0(select_overload{}, p, v);
}

/////////////////////////////////////////////////////////////////////
// RECORD REFLECTION DATA

${#decls}$
${#isStruct}$
///////////////////////////
// struct ${qualName}$
template <>
struct record_reflect<${qualName}$> {
	// attribute instances
${#attrs}$
	static constexpr auto A_${attrID}$ = ${initializer}$;
${/attrs}$

${#numPublicFields}$ 
	static const std::array<field, ${numPublicFields}$> field_data;
${/numPublicFields}$
${#numBases}$ 
	static const std::array<std::type_index, ${numBases}$> bases_data;
${/numBases}$
${#numAttrs}$
	static const std::array<attribute, ${numAttrs}$> attr_data;
${/numAttrs}$
	static const record_t metaobj;

	// field access thunks
	${#fields}$ 
	${#isPublic}$
	static void* field_thunk_${name}$(void* ptr) {
		return &reinterpret_cast<${classQualName}$*>(ptr)->${name}$;
	}
	${/isPublic}$
	${/fields}$

	static void serialize(packer& p, const void* data);
};

${#numPublicFields}$ 
const std::array<field, ${numPublicFields}$> record_reflect<${qualName}$>::field_data  { {
	${#fields}$ 
	${#isPublic}$
	field { "${name}$", "${qualName}$", ${#attr:meta::friendly_name}$ ${.}$.name ${/attr:meta::friendly_name}$ ${^attr:meta::friendly_name}$ "${name}$" ${/attr:meta::friendly_name}$, std::type_index{typeid(${qualType}$)}, offsetof(${classQualName}$, ${name}$), &record_reflect<${classQualName}$>::field_thunk_${name}$},
	${/isPublic}$
	${/fields}$
}};
${/numPublicFields}$

${#numBases}$ 
const std::array<std::type_index, ${numBases}$> record_reflect<${qualName}$>::bases_data { {
	${#bases}$ 
	std::type_index { typeid(${baseClassName}$) } ,
	${/bases}$
} };
${/numBases}$

${#numAttrs}$
const std::array<attribute, ${numAttrs}$> record_reflect<${qualName}$>::attr_data;
${/numAttrs}$

const record_t record_reflect<${qualName}$>::metaobj { "${qualName}$", 
	${#numPublicFields}$ record_reflect<${qualName}$>::field_data ${/numPublicFields}$ ${^numPublicFields}$ gsl::span<field>{} ${/numPublicFields}$,
	${#numBases}$ record_reflect<${qualName}$>::bases_data ${/numBases}$ ${^numBases}$ gsl::span<std::type_index>{} ${/numBases}$,
	{},	// attribute table
	&record_reflect<${qualName}$>::serialize,	// serialize
	nullptr // deserialize
	};

template <>
const type* type_of<${qualName}$>() {
return &record_reflect<${qualName}$>::metaobj;
}

${/isStruct}$
${/decls}$


/////////////////////////////////////////////////////////////////////
// ENUM REFLECTION DATA

///////////////////////////
// helpers
template <typename T>
uint64_t get_enum_value(const void* data) { return *reinterpret_cast<const T*>(data); }
template <typename T>
void set_enum_value(void* data, uint64_t value) { *reinterpret_cast<T*>(data) = value; }

template <typename T>
struct enum_reflect;

${#decls}$
${#isEnum}$
template<> struct enum_reflect<${qualName}$> 
{
${#numEnumerators}$ 
	static const std::array<enumerator, ${.}$> enumerator_data;
${/numEnumerators}$	
	static const enum_t metaobj;
	static void serialize(packer& p, const void* data) ;
};

${#numEnumerators}$ 
const std::array<enumerator, ${numEnumerators}$> enum_reflect<${qualName}$>::enumerator_data  { {
	${#enumerators}$ 
	enumerator { "${name}$", ${#attr:meta::friendly_name}$ ${.}$.name ${/attr:meta::friendly_name}$ ${^attr:meta::friendly_name}$ "${name}$" ${/attr:meta::friendly_name}$, static_cast<uint64_t>(${qualName}$)},
	${/enumerators}$
}};
${/numEnumerators}$

const enum_t enum_reflect<${qualName}$>::metaobj { "${qualName}$", 
	${#numEnumerators}$ enum_reflect<${qualName}$>::enumerator_data ${/numEnumerators}$ ${^numEnumerators}$ gsl::span<enumerator>{} ${/numEnumerators}$,	// enumerators
	&get_enum_value<std::underlying_type_t<${qualName}$>>,	// get_value
	&set_enum_value<std::underlying_type_t<${qualName}$>>,	// set_value
	{},	// attribute table
	&enum_reflect<${qualName}$>::serialize, // serialize
	nullptr		//deserialize
};

///////////////////////////
// enum ${qualName}$
template <> const char* get_enumerator_name<${qualName}$, void>(${qualName}$ value) {
	switch (value) {
	${#enumerators}$
	case ${qualName}$: return "${name}$";
	${/enumerators}$
	default: return "<invalid>";
	}
}

// generated by meta<enum_type>::get_enum_value(const char* name)
template <> ${qualName}$ get_enumerator_value<${qualName}$, void>(const char* name) {
	std::string namestr{name};
	${#enumerators}$
	${#isFirst}$
	if (namestr == "${name}$") { return ${qualName}$; }
	${/isFirst}$
	${^isFirst}$
	else if (namestr == "${name}$") { return ${qualName}$; }
	${/isFirst}$
	${/enumerators}$
	std::terminate();
}


template <>
const type* type_of<${qualName}$>() {
return &enum_reflect<${qualName}$>::metaobj;
}

${/isEnum}$
${/decls}$


/////////////////////////////////////////////////////////////////////
// SERIALIZATION

${#decls}$

${#isStruct}$
void record_reflect<${qualName}$>::serialize(packer& p, const void* data) 
{
auto obj = reinterpret_cast<const ${classQualName}$*>(data);
p.pack_map(${numPublicFields}$);
${#fields}$ 
${#isPublic}$
p.pack("${name}$");
serialize_impl(p, obj->${name}$);
${/isPublic}$
${/fields}$
}
${/isStruct}$

${#isEnum}$
void enum_reflect<${qualName}$>::serialize(packer& p, const void* data) 
{
auto v = *reinterpret_cast<const ${qualName}$*>(data);
p.pack(get_enumerator_name(v));
}
${/isEnum}$

${/decls}$


/////////////////////////////////////////////////////////////////////
// TYPEINDEX MAP
static std::unordered_map<std::type_index, const type*> typeindex_to_metaobject;
static bool typeindex_to_metaobject_initialized = false;

const type *type_of(std::type_index ti)
{
	if (!typeindex_to_metaobject_initialized) {
		using kv_pair = decltype(typeindex_to_metaobject)::value_type;
		typeindex_to_metaobject.insert({
			${#decls}$
			${#isEnum}$
			kv_pair{typeid(${qualName}$), &enum_reflect<${qualName}$>::metaobj},
			${/isEnum}$
			${/decls}$
			${#decls}$
			${#isStruct}$
			kv_pair{typeid(${qualName}$), &record_reflect<${qualName}$>::metaobj},
			${/isStruct}$
			${/decls}$
		});
		typeindex_to_metaobject_initialized = true;
	}
	auto it = typeindex_to_metaobject.find(ti);
	if (it != typeindex_to_metaobject.end()) {
		return it->second;
	}
	return nullptr;
}

template <typename T> struct meta_attr {};

struct meta_attr_entry {
	std::type_index attr_type;
	const void* data;
};

${#decls}$
${#isType}$
/*template <> struct meta_attr<${qualName}$> {
	// attribute instances for ${qualName}$
	${#attrs}$
	static constexpr ${qualType}$ A_${attrID}$ = ${initializer}$;
	${/attrs}$
	// attribute table
	const std::array<meta_attr_entry, ${numAttrs}$>& table() {
		static std::array<meta_attr_entry, ${numAttrs}$> data_ = { {
		${#attrs}$
			{ std::type_index{typeid(${qualType}$)}, &meta_attr<${qualName}$>::A_${attrID}$ },
			${/attrs}$
		} };
		return data_;
	}
};*/
${/isType}$
${/decls}$

}