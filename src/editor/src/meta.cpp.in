{{=${ }$=}}

${#metaHeaders}$
#include "${.}$"
${/metaHeaders}$
#include <exception>
#include <typeindex>
#include <cstdint>
#include <cstddef>

namespace meta 
{

/////////////////////////////////////////////////////////////////////
// RECORD REFLECTION DATA

// base template
template <typename T>
struct record_reflect;

${#decls}$
${#isStruct}$
///////////////////////////
// struct ${qualName}$
template <>
struct record_reflect<${qualName}$> {
	// attribute instances
${#attrs}$
	static constexpr auto A_${attrID}$ = ${initializer}$;
${/attrs}$

${#numPublicFields}$ 
	static const std::array<field, ${numPublicFields}$> field_data;
${/numPublicFields}$
${#numBases}$ 
	static const std::array<std::type_index, ${numBases}$> bases_data;
${/numBases}$
${#numAttrs}$
	static const std::array<attribute, ${numAttrs}$> attr_data;
${/numAttrs}$
	static const record_metaobject metaobj;
};

${#numPublicFields}$ 
const std::array<field, ${numPublicFields}$> record_reflect<${qualName}$>::field_data  { {
	${#fields}$ 
	${#isPublic}$
	field { "${name}$", "${qualName}$", ${#attr:meta::friendly_name}$ ${.}$.name ${/attr:meta::friendly_name}$ ${^attr:meta::friendly_name}$ "${name}$" ${/attr:meta::friendly_name}$, std::type_index{typeid(${qualType}$)}, offsetof(${classQualName}$, ${name}$) } ,
	${/isPublic}$
	${/fields}$
}};
${/numPublicFields}$

${#numBases}$ 
const std::array<std::type_index, ${numBases}$> record_reflect<${qualName}$>::bases_data { {
	${#bases}$ 
	std::type_index { typeid(${baseClassName}$) } ,
	${/bases}$
} };
${/numBases}$

${#numAttrs}$
const std::array<attribute, ${numAttrs}$> record_reflect<${qualName}$>::attr_data;
${/numAttrs}$


const record_metaobject record_reflect<${qualName}$>::metaobj { "${qualName}$", 
	${#numPublicFields}$ record_reflect<${qualName}$>::field_data ${/numPublicFields}$ ${^numPublicFields}$ gsl::span<field>{} ${/numPublicFields}$,
	${#numBases}$ record_reflect<${qualName}$>::bases_data ${/numBases}$ ${^numBases}$ gsl::span<std::type_index>{} ${/numBases}$ };

template <>
const metaobject* get_metaobject<${qualName}$>() {
return &record_reflect<${qualName}$>::metaobj;
}

${/isStruct}$
${/decls}$



/////////////////////////////////////////////////////////////////////
// ENUM REFLECTION DATA
${#decls}$
${#isEnum}$
///////////////////////////
// enum ${qualName}$
template <> const char* get_enum_constant_name<${qualName}$, std::true_type>(${qualName}$ value) {
	switch (value) {
	${#enumerators}$
	case ${qualName}$: return "${name}$";
	${/enumerators}$
	default: return "<invalid>";
	}
}

// generated by meta<enum_type>::get_enum_value(const char* name)
template <> ${qualName}$ get_enum_constant_value<${qualName}$, std::true_type>(const char* name) {
	std::string namestr{name};
	${#enumerators}$
	${#isFirst}$
	if (namestr == "${name}$") { return ${qualName}$; }
	${/isFirst}$
	${^isFirst}$
	else if (namestr == "${name}$") { return ${qualName}$; }
	${/isFirst}$
	${/enumerators}$
	std::terminate();
}
${/isEnum}$
${/decls}$


static std::unordered_map<std::type_index, const metaobject*> typeindex_to_metaobject;
static bool typeindex_to_metaobject_initialized = false;

const metaobject *get_metaobject(std::type_index ti)
{
	if (!typeindex_to_metaobject_initialized) {
		using kv_pair = decltype(typeindex_to_metaobject)::value_type;
		typeindex_to_metaobject.insert({
			${#decls}$
			${#isEnum}$
			kv_pair{typeid(${qualName}$), nullptr},
			${/isEnum}$
			${/decls}$
			${#decls}$
			${#isStruct}$
			kv_pair{typeid(${qualName}$), &record_reflect<${qualName}$>::metaobj},
			${/isStruct}$
			${/decls}$
		});
		typeindex_to_metaobject_initialized = true;
	}
	auto it = typeindex_to_metaobject.find(ti);
	if (it != typeindex_to_metaobject.end()) {
		return it->second;
	}
	return nullptr;
}

template <typename T> struct meta_attr {};

struct meta_attr_entry {
	std::type_index attr_type;
	const void* data;
};

${#decls}$
${#isType}$
/*template <> struct meta_attr<${qualName}$> {
	// attribute instances for ${qualName}$
	${#attrs}$
	static constexpr ${qualType}$ A_${attrID}$ = ${initializer}$;
	${/attrs}$
	// attribute table
	const std::array<meta_attr_entry, ${numAttrs}$>& table() {
		static std::array<meta_attr_entry, ${numAttrs}$> data_ = { {
		${#attrs}$
			{ std::type_index{typeid(${qualType}$)}, &meta_attr<${qualName}$>::A_${attrID}$ },
			${/attrs}$
		} };
		return data_;
	}
};*/
${/isType}$
${/decls}$

}