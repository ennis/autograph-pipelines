{{=${ }$=}}

${#decls}$
${#isRecord}$
std::array<meta::field, ${numFields}$> fields = { 
	${#fields}$ 
	${#isPublic}$
	meta::field { "${qualType}$", "${name}$" } 
	${/isPublic}$
	${/fields}$
};
${/isRecord}$
${/decls}$



${#decls}$
${#isEnum}$
// generated by meta<enum_type>::get_enum_name(enum_type value)
template <> const char* meta<${qualName}$>::get_enum_name(${qualName}$ value) {
	switch (value) {
	${#enumerators}$
	case ${name}$: return "${name}$";
	${/enumerators}$
	default: return "<invalid>";
	}
}

// generated by meta<enum_type>::get_enum_value(const char* name)
template <> ${qualName}$ meta<${qualName}$>::get_enum_value(const char* name) {
	std::string namestr{name};
	${#enumerators}$
	${#isFirst}$
	if (namestr == "${name}$") { return true; }
	${/isFirst}$
	${^isFirst}$
	else if (namestr == "${name}$") { return true; }
	${/isFirst}$
	${/enumerators}$
	return false;
}
${/isEnum}$
${/decls}$


${#decls}$
// attribute instances for ${qualName}$
namespace attr_${declID}$ {
${#attributes}$
${qualType} i_${attrID}$ = ${initializerExpr}$;
${/attributes}$
}

// attribute table for ${qualName}$
// typeinfo hash code -> pointer to attribute instance
std::array<meta::attr_entry, ${numAttr}$> attr_table_${declID}$ = {{
${#attributes}$
	{ std::type_index{typeid(${qualType}$)}, &attr_${declID}$::${attrID}$ },
${/attributes}$
}};
${/decls}$
